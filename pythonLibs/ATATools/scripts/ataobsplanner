#!/usr/bin/env python
import tkinter as tk
from tkcalendar import DateEntry
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np

from parse import parse

from astropy.coordinates import EarthLocation, AltAz, ICRS, SkyCoord
from astropy import units as u
from astropy.time import Time, TimeDelta

from pytz import timezone

import ATATools.ata_sources as check

import matplotlib.dates as mdates
import matplotlib.pyplot as plt
import matplotlib as mpl

import datetime

# Load custom Matplotlib rc parameters
exec(open("/home/sonata/utils/rcparams.py", "r").read())

HARD_EL_LIM = 16.5 #degrees
SOFT_EL_LIM = 20.0 #degrees
OBSERVING_LOCATION = EarthLocation.from_geodetic(lat=40.8178*u.deg, lon=-121.4733*u.deg)

#Time to start observing script, change frequencies, RF/IF gain set, etc...
INITIAL_OVERHEAD_TIME = 70 # seconds

# Slew rate:
SLEW_RATE = 1.5 #deg/sec
OBS_OVERHEAD = 10 #seconds

INITIAL_AZ, INITIAL_EL = (0, 18) #parked position

class ObsPlan(object):
    def __init__(self, start_time, obs_overhead = False, slew_time = False):
        self.source_list = []
        self.obs_plan = []
        self.start_time = start_time
        self.time_incr = start_time
        self.obs_overhead = obs_overhead
        if obs_overhead:
            self.add_initial_obs_overhead()
        self.slew_time = slew_time
        self.current_position = (INITIAL_AZ, INITIAL_EL)

    def add_initial_obs_overhead(self):
        self.time_incr += INITIAL_OVERHEAD_TIME * u.second


    def add_obs_block(self, source, duration):
        # Assume source to
        if source.lower().startswith("radec"):
            source_info = self.parse_radec(source)
        else:
            source_info = check.check_source(source)

        source_info['duration'] = duration
        # simulate a slew from "current_position" to "new_position"
        if self.slew_time:
            new_position = self.get_telescope_position(source_info, self.time_incr)
            slew_time = self.get_slew_time(self.current_position, new_position)
            self.time_incr += slew_time * u.second
            self.current_position = new_position

        # simulate overhead to start an observation
        if self.obs_overhead:
            self.time_incr += OBS_OVERHEAD * u.second

        source_info['start_time'] = self.time_incr
        self.time_incr += duration * u.second
        source_info['end_time'] = self.time_incr

        if self.slew_time:
            new_position = self.get_telescope_position(source_info, self.time_incr)
            self.current_position = new_position

        self.obs_plan.append(source_info)

    def parse_radec(self, source):
        source_info = {}
        source_info['object'] = source

        # extract radec from source_name
        res = parse('radec{ra},{dec}', source.lower())
        try:
            source_info['ra'] = float(res['ra'])
            source_info['dec'] = float(res['dec'])
        except Exception as e:
            raise Exception("Error in parsing RA/Dec from entry: '%s'" %source)
        return source_info

    def get_telescope_position(self, source_info, time):
        ra = source_info['ra']
        dec = source_info['dec']
        source_coords = ICRS(ra=ra*u.hour, dec=dec*u.deg)
        target = SkyCoord(source_coords)

        altaz = target.transform_to(AltAz(obstime=time, location=OBSERVING_LOCATION))
        return (altaz.az.deg, altaz.alt.deg)

    def get_slew_time(self, position_1, position_2):
        az1, el1 = position_1
        az2, el2 = position_2
        #max(180, abs(delta_az)) is an assumption, but good enough
        distance = np.sqrt(min(180, abs(az2 - az1)) ** 2 + (el2 - el1)**2) # degrees
        time = distance / SLEW_RATE
        return time


class PlotApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Observing plan plotter")

        # Create a frame for the plot
        self.frame_plot = tk.Frame(root)
        self.frame_plot.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Create a frame for user input
        self.frame_input = tk.Frame(root)
        self.frame_input.pack(side=tk.RIGHT, fill=tk.Y, padx=20, pady=20)

        # Date selection
        self.date_label = tk.Label(self.frame_input, text="Select Start Date [PST]:", font=("Helvetica", 14))
        self.date_label.pack(pady=2, anchor='w')

        # Apply a larger font directly to the DateEntry
        self.date_entry = DateEntry(self.frame_input, width=12, background='darkblue', 
                                    foreground='white', borderwidth=2, font=("Helvetica", 14))
        self.date_entry.pack(pady=2, anchor='w')

        # Time input using Spinboxes for hours and minutes
        self.time_label = tk.Label(self.frame_input, text="Select Time (HH:MM) [PST]:", font=("Helvetica", 14))
        self.time_label.pack(pady=2, anchor='w')

        self.time_frame = tk.Frame(self.frame_input)  # Container for spinboxes
        self.time_frame.pack(pady=1, anchor='w')

        # Get time now to fill in defaults
        dt_now = datetime.datetime.now(tz=timezone(('US/Pacific')))
        hh_now, mm_now = dt_now.hour, dt_now.minute

        self.hours_spin = tk.Spinbox(self.time_frame, from_=0, to=23, width=5, 
            format="%02.0f", font=("Helvetica", 14), textvariable=tk.DoubleVar(value=hh_now))
        self.minutes_spin = tk.Spinbox(self.time_frame, from_=0, to=59, width=5, 
            format="%02.0f", font=("Helvetica", 14), textvariable=tk.DoubleVar(value=mm_now))
        self.hours_spin.pack(side=tk.LEFT, padx=(0, 5))
        self.minutes_spin.pack(side=tk.LEFT)

        # Source Name input
        self.source_name_label = tk.Label(self.frame_input, text="Source Name:", font=("Helvetica", 14))
        self.source_name_label.pack(pady=5, anchor='w')
        self.source_name_entry = tk.Entry(self.frame_input, font=("Helvetica", 14))
        self.source_name_entry.pack(pady=2, fill=tk.X)

        # Observing Time input
        self.observing_time_label = tk.Label(self.frame_input, text="Observing Time [sec]:", font=("Helvetica", 14))
        self.observing_time_label.pack(pady=5, anchor='w')
        self.observing_time_entry = tk.Entry(self.frame_input, font=("Helvetica", 14))
        self.observing_time_entry.pack(pady=2, fill=tk.X)

        # Frame to hold the checkboxes
        self.checkbox_frame = tk.Frame(self.frame_input)
        self.checkbox_frame.pack(pady=5)

        # Checkboxes for "Initial Overhead" and "Slew Time"
        self.obs_overhead_var = tk.IntVar()
        self.slew_time_var = tk.IntVar()

        self.obs_overhead_check = tk.Checkbutton(self.checkbox_frame, text="Observation Overhead", variable=self.obs_overhead_var, font=("Helvetica", 12))
        self.obs_overhead_check.grid(row=0, column=0, padx=5)

        self.slew_time_check = tk.Checkbutton(self.checkbox_frame, text="Slew Time", variable=self.slew_time_var, font=("Helvetica", 12))
        self.slew_time_check.grid(row=0, column=1, padx=5)

        # Add Entry Button
        self.add_button = tk.Button(self.frame_input, text="Add Entry", command=self.add_entry, font=("Helvetica", 14))
        self.add_button.pack(pady=10)

        # Duplicate Entry Button
        self.duplicate_button = tk.Button(self.frame_input, text="Duplicate Entry[ies]", command=self.duplicate_entry, font=("Helvetica", 14))
        self.duplicate_button.pack(pady=10)

        # Button to remove selected entries
        self.remove_button = tk.Button(self.frame_input, text="Remove Entry[ies]", command=self.remove_entry, font=("Helvetica", 14))
        self.remove_button.pack(pady=5)

        # Frame to hold the listbox and scrollbar
        self.listbox_frame = tk.Frame(self.frame_input)
        self.listbox_frame.pack(pady=10, fill=tk.BOTH, expand=True)

        # Listbox to display added entries
        self.entry_listbox = tk.Listbox(self.listbox_frame, height=15, selectmode=tk.MULTIPLE, font=("Helvetica", 12))
        self.entry_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # Scrollbar for the listbox
        self.scrollbar = tk.Scrollbar(self.listbox_frame, orient="vertical", command=self.entry_listbox.yview)
        self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Link the scrollbar with the listbox
        self.entry_listbox.config(yscrollcommand=self.scrollbar.set)


        # Reset Button
        self.reset_button = tk.Button(self.frame_input, text="Reset All", command=self.reset_all, font=("Helvetica", 14))
        self.reset_button.pack(side=tk.BOTTOM, pady=5)

        # Generate button at the bottom
        self.generate_button = tk.Button(self.frame_input, text="Generate Plot", command=self.generate_plot, font=("Helvetica", 14))
        self.generate_button.pack(side=tk.BOTTOM, pady=5)

        # Create a Matplotlib figure with increased size
        self.figure, self.ax = plt.subplots(figsize=(10, 6))  # Width: 10 inches, Height: 6 inches
        self.canvas = FigureCanvasTkAgg(self.figure, master=self.frame_plot)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        # To store source names and observing times
        self.entries = []

        # Bind the "Q" key to quit the app
        self.root.bind("<q>", self.quit_app)

        # Bind the "Q" key to delete the selected entry
        self.root.bind("<d>", self.remove_entry)

        # Bind the "BackSpace" key to delete the selected entry
        self.root.bind("<BackSpace>", self.remove_entry)

        # Initialize dragging variables
        self.dragging = False
        self.dragged_index = None

        # Bind mouse events for dragging
        self.entry_listbox.bind("<Button-1>", self.on_click)
        self.entry_listbox.bind("<B1-Motion>", self.on_drag)
        self.entry_listbox.bind("<ButtonRelease-1>", self.on_release)

        # Bind the "Escape" key to reset the selection
        self.root.bind("<Escape>", self.reset_selection)

        # Error display label
        self.error_label = tk.Label(self.frame_input, text="", fg="red", font=("Helvetica", 12))
        self.error_label.pack(pady=5)

    def quit_app(self, event=None):
        """Close the application."""
        self.root.destroy()  # Destroy the main window

    def remove_entry(self, event=None):
        """Removes selected entries from the listbox."""
        selected_indices = list(self.entry_listbox.curselection())  # Get selected indices
        
        # Remove selected entries in reverse order to maintain indices
        for index in reversed(selected_indices):
            self.entry_listbox.delete(index)

    def add_entry(self):
        """Adds a source name and observing time to the list."""
        source_name = self.source_name_entry.get()
        observing_time = self.observing_time_entry.get()

        if source_name and observing_time:
            entry = f"{source_name}, {observing_time} sec"
            self.entries.append(entry)

            # Update the listbox with the new entry
            self.entry_listbox.insert(tk.END, entry)

            # Clear the input fields after adding
            self.source_name_entry.delete(0, tk.END)
            self.observing_time_entry.delete(0, tk.END)

    def duplicate_entry(self):
        """Duplicates the selected entries in the listbox."""
        selected_indices = self.entry_listbox.curselection()
        
        if selected_indices:  # Check if any entries are selected
            for index in selected_indices:
                selected_entry = self.entry_listbox.get(index)
                # Insert the duplicated entry at the end
                self.entry_listbox.insert(tk.END, selected_entry)
        else:
            print("No entry selected to duplicate.")

    def reset_selection(self, event=None):
        """Reset the selection of the listbox."""
        self.entry_listbox.selection_clear(0, tk.END)  # Clear selection

    def on_click(self, event):
        """Handle mouse click on the listbox."""
        self.dragging = True
        self.dragged_index = self.entry_listbox.nearest(event.y)  # Get the index of the clicked item

    def on_drag(self, event):
        """Handle dragging of listbox items."""
        if self.dragging:
            current_index = self.entry_listbox.nearest(event.y)  # Get the index of the item currently under the mouse
            if current_index != self.dragged_index:
                # Move the item if the indices are different
                item_text = self.entry_listbox.get(self.dragged_index)
                self.entry_listbox.delete(self.dragged_index)
                self.entry_listbox.insert(current_index, item_text)
                self.dragged_index = current_index  # Update the index of the dragged item

    def on_release(self, event):
        """Handle mouse release to stop dragging."""
        self.dragging = False
        self.dragged_index = None  # Reset the dragged index

    def display_all_entries(self):
        """Displays all entries in the listbox."""
        all_entries = self.entry_listbox.get(0, tk.END)  # Get all entries
        print("All entries in the listbox:")
        for entry in all_entries:
            print(entry)

    def generate_plot(self):
        self.clear_error()
        self.root.config(cursor="watch")
        self.root.update()

        # Clear the previous plot
        self.ax.clear()

        # Get user input
        date_selected = self.date_entry.get()
        hours = int(self.hours_spin.get())
        minutes = int(self.minutes_spin.get())
        time_selected = hours + minutes / 60.0

        # Temporary default title
        default_title = f"Plot generated on {date_selected} at {hours:02}:{minutes:02}"

        start_time = datetime.datetime.strptime(
                f"{date_selected} {hours:02}:{minutes:02}", "%m/%d/%y %H:%M")
        pacific = timezone('US/Pacific')

        localized_time = pacific.localize(start_time)

        start_time = Time(localized_time)

        # Create the obs plan
        obs = ObsPlan(start_time, self.obs_overhead_var.get(),
                self.slew_time_var.get())

        # Cycle through all the entries:
        for entry in self.entry_listbox.get(0, tk.END):
            res = parse('{source_name}, {observing_time} sec', entry)
            source_name = res['source_name']
            try:
                obs_time = int(res['observing_time'])
            except ValueError as e:
                self.display_error("Input correct obstime for source %s" %source_name)
                self.root.config(cursor="")
                self.root.update()
                raise
            try:
                obs.add_obs_block(source_name, obs_time)
            except Exception as e:
                self.root.config(cursor="")
                self.root.update()
                self.display_error(str(e))
                raise


        obs_tracks = []

        t_all = (obs.time_incr - obs.start_time).to_value(u.second)
        obs_times = obs.start_time + t_all * np.linspace(-0.05, 1.05, 500) * u.second
        obs_times_pdate = obs_times.to_value("plot_date")

        unique_sources = list(set(i['object'] for i in obs.obs_plan))
        color_cycler = {}
        tracks = {}

        try:
            # loop through sources to plot the tracks
            for isource, source in enumerate(unique_sources):
                if source.lower().startswith("radec"):
                    source_info = obs.parse_radec(source)
                else:
                    source_info = check.check_source(source)
                ra = source_info['ra']
                dec = source_info['dec']
                source_coords = ICRS(ra=ra*u.hour, dec=dec*u.deg)
                target = SkyCoord(source_coords)

                altaz = target.transform_to(AltAz(obstime=obs_times, location=OBSERVING_LOCATION))
                tracks[source_info['object']] = altaz.alt

                #plt.gca().xaxis.set_major_locator(mdates.DayLocator(interval=10))
                #plt.plot(days,y)
                self.ax.plot(obs_times_pdate, altaz.alt, label=source_info['object'])
                color_cycler[source_info['object']] = list(mpl.rcParams['axes.prop_cycle'])[isource]['color']

            # plot the start and end times, and the overhead fill
            if self.obs_overhead_var.get() or self.slew_time_var.get():
                sdate = obs.start_time.to_value("plot_date")
                edate = obs.time_incr.to_value("plot_date")
                self.ax.axvline(x = sdate, color = 'black', linestyle = ':', alpha=1)
                self.ax.axvline(x = edate, color = 'black', linestyle = ':', alpha=1)

                obs_block0 = obs.obs_plan[0]
                sdate_obs0 = obs_block0['start_time'].to_value("plot_date")
                self.ax.fill_betweenx([0,90], sdate_obs0, sdate, hatch="//", alpha=0,
                        label="overhead + slew")
                edate_obs0 = obs_block0['end_time'].to_value("plot_date")

                for obs_block in obs.obs_plan[1:]:
                    sdate = obs_block['start_time'].to_value("plot_date")
                    self.ax.fill_betweenx([0,90], edate_obs0, sdate, hatch="//", alpha=0)
                    edate_obs0 = obs_block['end_time'].to_value("plot_date")

            error_in_plan = 0

            # now loop through the observing plan
            for obs_block in obs.obs_plan:
                source_name = obs_block['object']
                color = color_cycler[source_name]
                sdate = obs_block['start_time'].to_value("plot_date")
                edate = obs_block['end_time'].to_value("plot_date")
                self.ax.fill_betweenx([0,90], edate, sdate, color = color, alpha=0.3)
                self.ax.axvline(x = sdate, color = 'black', linestyle = ':', alpha=1)
                self.ax.axvline(x = edate, color = 'black', linestyle = ':', alpha=1)

                el_track = tracks[source_name]

                el_track_seg = el_track[(obs_times_pdate >= sdate) & (obs_times_pdate <= edate)]
                el_track_seg = el_track_seg.deg

                # if any source has set
                if np.any(el_track_seg <= HARD_EL_LIM):
                    error_in_plan = 2
                    self.ax.fill_betweenx([0,HARD_EL_LIM], edate, sdate, color = 'red', alpha=1)
                elif np.any(el_track_seg <= SOFT_EL_LIM):
                    if error_in_plan != 2:
                        error_in_plan = 1
                    self.ax.fill_betweenx([0,SOFT_EL_LIM], edate, sdate, color = 'orange', alpha=1)

            self.ax.legend(fontsize=18)
            self.ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d:%H:%M'))
            self.figure.autofmt_xdate()

            if error_in_plan == 2:
                self.ax.set_title("CHECK PLAN - SOURCE[S] BELOW HORIZON", color='red')
            elif error_in_plan == 1:
                self.ax.set_title("Check plan - source[s] can get below horizon", color='orange')
            else:
                self.ax.set_title("No errors in plan", color='green')

            self.ax.axhline(y = HARD_EL_LIM, color = 'r', linestyle = '--') 
            self.ax.axhline(y = SOFT_EL_LIM, color='orange', linestyle='--')
            self.ax.grid(alpha=0.5)
            
            self.ax.set_ylim([-0, 90])

            self.ax.set_ylabel("Elevation [deg]")
            self.ax.set_xlabel("Time [PST]")

            self.canvas.draw()

        except Exception as e:
            print("Error:", e)

        self.root.config(cursor="")
        self.root.update()

    def reset_all(self):
        """Resets all input fields and clears the listbox."""
        # Reset Date and Time fields
        self.date_entry.set_date(self.date_entry._date.today())

        # Get time now to fill in defaults
        dt_now = datetime.datetime.now(tz=timezone(('US/Pacific')))
        hh_now, mm_now = dt_now.hour, dt_now.minute

        self.hours_spin.delete(0, tk.END)
        self.hours_spin.insert(0, f'{hh_now:02}')
        self.minutes_spin.delete(0, tk.END)
        self.minutes_spin.insert(0, f'{mm_now:02}')

        # Reset Source Name and Observing Time fields
        self.source_name_entry.delete(0, tk.END)
        self.observing_time_entry.delete(0, tk.END)

        # Clear the Listbox and reset entries
        self.entry_listbox.delete(0, tk.END)
        self.entries.clear()

        # Clear the plot
        self.ax.clear()
        self.canvas.draw()

        # Clear any errors
        self.clear_error()

    def display_error(self, message):
        """Display an error message in the error label."""
        self.error_label.config(text=message)

    def clear_error(self):
        """Clear the error message."""
        self.error_label.config(text="")

if __name__ == "__main__":
    root = tk.Tk()
    root.geometry("1500x900")  # Set the window size to 1450x900 pixels
    app = PlotApp(root)
    root.mainloop()
